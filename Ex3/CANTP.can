/*@!Encoding:65001*/
/* CAN-TP Library for ISO 15765-2 */

variables {
  /* Constants */
  const int CAN_TP_SF = 0x00;        // Single Frame
  const int CAN_TP_FF = 0x10;        // First Frame
  const int CAN_TP_CF = 0x20;        // Consecutive Frame
  const int CAN_TP_FC = 0x30;        // Flow Control
  const int CAN_TP_MAX_DATA = 4095;  // Max CAN-TP data length
  const int CAN_TP_MAX_PAYLOAD = 7;  // Max payload per CAN frame (SF/CF)
  const int CANTP_COUNTER_AS = 1000; // AS timeout in ms
  
  /* Struct for CAN-TP state */
  struct cantp_state {
    byte data[CAN_TP_MAX_DATA];  // Data buffer
    word length;                 // Total data length
    word bytes_sent;             // Bytes sent/received
    byte sn;                     // Sequence number for CF
    byte bs_rem;                 // Remaining frames in block
    byte bs_max;                 // Block size from FC
    byte stmin;                  // STmin from FC (ms)
    byte fs;                     // Flow Status
    byte sending;                // 1 if sending, 0 if receiving
    byte active;                 // 1 if TP session active
    dword tx_id;                 // CAN message ID for the session
  } tp_state;
  
  msTimer stmin_timer;  // Timer for STmin
  msTimer as_timer;     // Timer for AS timeout
  message 0x7DF msg;    // Default message ID
}

/* Initialize CAN-TP state */
void cantp_init() {
  tp_state.length = 0;
  tp_state.bytes_sent = 0;
  tp_state.sn = 0;
  tp_state.bs_rem = 0;
  tp_state.bs_max = 0;
  tp_state.stmin = 0;
  tp_state.fs = 0;
  tp_state.sending = 0;
  tp_state.active = 0;
  tp_state.tx_id = 0;
  cancelTimer(stmin_timer);
  cancelTimer(as_timer);
}

/* Start sending data */
int cantp_send(byte data[], word len, dword tx_id) {
  word i;
  if (len == 0 || len > CAN_TP_MAX_DATA || tp_state.active) return -1;
  
  for (i = 0; i < len; i++) {
    tp_state.data[i] = data[i];
  }
  tp_state.length = len;
  tp_state.bytes_sent = 0;
  tp_state.sn = 0;
  tp_state.sending = 1;
  tp_state.active = 1;
  tp_state.tx_id = tx_id;
  
  if (len <= CAN_TP_MAX_PAYLOAD) {
    cantp_send_sf(tx_id);
  } else {
    cantp_send_ff(tx_id);
  }
  return 0;
}

/* Send Single Frame */
void cantp_send_sf(dword tx_id) {
  word i;
  
  msg.id = tx_id;
  msg.dlc = 8;
  msg.byte(0) = CAN_TP_SF | (tp_state.length & 0x0F);
  
  for (i = 0; i < tp_state.length; i++) {
    msg.byte(i + 1) = tp_state.data[i];
  }
  for (i = tp_state.length + 1; i < 8; i++) {
    msg.byte(i) = 0x55;
  }
  
  setTimer(as_timer, CANTP_COUNTER_AS);
  output(msg);
  tp_state.active = 0;
}

/* Send First Frame */
void cantp_send_ff(dword tx_id) {
  word i;
  
  msg.id = tx_id;
  msg.dlc = 8;
  msg.byte(0) = CAN_TP_FF | ((tp_state.length >> 8) & 0x0F);
  msg.byte(1) = tp_state.length & 0xFF;
  
  for (i = 0; i < 6; i++) {
    msg.byte(i + 2) = tp_state.data[i];
  }
  
  tp_state.bytes_sent = 6;
  setTimer(as_timer, CANTP_COUNTER_AS);
  output(msg);
}

/* Send Consecutive Frame */
void cantp_send_cf(dword tx_id) {
  word i;
  word remaining;
  word payload;
  
  remaining = tp_state.length - tp_state.bytes_sent;
  payload = (remaining > CAN_TP_MAX_PAYLOAD) ? CAN_TP_MAX_PAYLOAD : remaining;
  
  msg.id = tx_id;
  msg.dlc = 8;
  msg.byte(0) = CAN_TP_CF | (tp_state.sn & 0x0F);
  
  for (i = 0; i < payload; i++) {
    msg.byte(i + 1) = tp_state.data[tp_state.bytes_sent + i];
  }
  for (i = payload; i < 7; i++) {
    msg.byte(i + 1) = 0x55;
  }
  
  tp_state.bytes_sent += payload;
  tp_state.sn = (tp_state.sn + 1) & 0x0F;
  tp_state.bs_rem--;
  output(msg);
  
  if (tp_state.bytes_sent >= tp_state.length) {
    tp_state.active = 0;
  }
}

/* Send Flow Control Frame */
void cantp_send_fc(dword tx_id, byte fs, byte bs, byte stmin) {
  word i;
  
  msg.id = tx_id;
  msg.dlc = 8;
  msg.byte(0) = CAN_TP_FC | (fs & 0x0F);
  msg.byte(1) = bs;
  msg.byte(2) = stmin;
  for (i = 3; i < 8; i++) {
    msg.byte(i) = 0x55;
  }
  output(msg);
}

/* Handle received CAN-TP frame */
on message CAN1.* {
  byte pci;
  pci = this.byte(0) & 0xF0;
  if (tp_state.active || pci == CAN_TP_SF || pci == CAN_TP_FF) {
    if (pci == CAN_TP_SF) {
      cantp_handle_sf(this);
    } else if (pci == CAN_TP_FF) {
      cantp_handle_ff(this, this.id);
    } else if (pci == CAN_TP_CF) {
      cantp_handle_cf(this);
    } else if (pci == CAN_TP_FC && tp_state.sending) {
      cantp_handle_fc(this, this.id);
    }
  }
}

/* Handle Single Frame */
void cantp_handle_sf(message CAN1.* msg) {
  word i;
  byte len;
  
  len = msg.byte(0) & 0x0F;
  if (len > CAN_TP_MAX_PAYLOAD) return;
  
  tp_state.length = len;
  for (i = 0; i < len; i++) {
    tp_state.data[i] = msg.byte(i + 1);
  }
  tp_state.active = 0;
}

/* Handle First Frame */
void cantp_handle_ff(message CAN1.* msg, dword tx_id) {
  word i;
  word len;
  
  len = ((msg.byte(0) & 0x0F) << 8) | msg.byte(1);
  if (len > CAN_TP_MAX_DATA) {
    cantp_send_fc(tx_id, 2, 0, 0);
    return;
  }
  
  tp_state.length = len;
  tp_state.bytes_sent = 0;
  tp_state.sn = 0;
  tp_state.sending = 0;
  tp_state.active = 1;
  tp_state.tx_id = tx_id;
  
  for (i = 0; i < 6; i++) {
    tp_state.data[i] = msg.byte(i + 2);
  }
  tp_state.bytes_sent = 6;
}

/* Handle Consecutive Frame */
void cantp_handle_cf(message CAN1.* msg) {
  word i;
  word remaining;
  word payload;
  byte sn;
  
  remaining = tp_state.length - tp_state.bytes_sent;
  payload = (remaining > CAN_TP_MAX_PAYLOAD) ? CAN_TP_MAX_PAYLOAD : remaining;
  sn = msg.byte(0) & 0x0F;
  
  if (sn != tp_state.sn) return;
  for (i = 0; i < payload; i++) {
    tp_state.data[tp_state.bytes_sent + i] = msg.byte(i + 1);
  }
  
  tp_state.bytes_sent += payload;
  tp_state.sn = (tp_state.sn + 1) & 0x0F;
  if (tp_state.bytes_sent >= tp_state.length) {
    tp_state.active = 0;
  }
}

/* Handle Flow Control Frame */
void cantp_handle_fc(message CAN1.* msg, dword tx_id) {
  byte fs;
  
  fs = msg.byte(0) & 0x0F;
  tp_state.fs = fs;
  tp_state.bs_max = msg.byte(1);
  tp_state.stmin = msg.byte(2);
  tp_state.bs_rem = tp_state.bs_max;
  
  if (fs == 0 && tp_state.active) {
    setTimer(stmin_timer, tp_state.stmin);
  } else if (fs == 2) {
    tp_state.active = 0;
  }
}

/* Timer callback for STmin */
on timer stmin_timer {
  if (tp_state.active && tp_state.sending && tp_state.fs == 0) {
    cantp_send_cf(tp_state.tx_id);
    if (tp_state.bs_rem == 0 && tp_state.bytes_sent < tp_state.length) {
      tp_state.fs = 1;
    } else if (tp_state.active) {
      setTimer(stmin_timer, tp_state.stmin);
    }
  }
}

/* Timer callback for AS timeout */
on timer as_timer {
  if (tp_state.active && tp_state.sending) {
    write("AS timeout occurred");
    tp_state.active = 0;
  }
}

/* Get received data */
void cantp_get_received_data(byte dest[], word maxLen, word &outLen) {
  word i;
  
  outLen = (tp_state.length < maxLen) ? tp_state.length : maxLen;
  for (i = 0; i < outLen; i++) {
    dest[i] = tp_state.data[i];
  }
}
